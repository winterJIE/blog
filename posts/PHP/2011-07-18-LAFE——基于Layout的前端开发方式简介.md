## LAFE——基于Layout的前端开发方式简介

LAFE是个神马东东呢？听起来像个新鲜玩艺儿吧？

要解释这个还蛮费劲的。而我这个人又比较懒，不喜欢长篇大论。（看我前一篇文章是啥时候更新的就知道我有多懒了=.=）

为什么我不经常更新呢，一是我比较懒，二是我一般不喜欢经常码字的，特别是比较忙的时候，如果废话就会被老大发现我工作不饱和，然后说不定就有更多的活要做了……

额……

还是言归正传，谈谈LAFE吧

<!--more-->

好吧，我们天天说模块化模块化，但是没有人真正说清楚，一般的开发过程中，如果我们要把前端设计成模块化开发，究竟应该肿么写代码才比较爽。如果只是简单把页面分成一块块的，然后把这些模块一一载入进来，拼成页面，那再简单也不过了。

但是现实没这么理想化，如果一个页面足够复杂，那么可能包含一个头部、一个底部、中间包含一个边拦，一个主栏，主栏里边可能又嵌套包含一个有头、身子、底的复杂结构，然后这种结构还能多重嵌套，这时候你就知道有多烦了。

模块化不仅仅只是拆，更烦的是拼装，如何把一个复杂页面很快速拼装出来呢，好吧，我们看看传统的方式是如何工作滴——

最初的办法是全部写在views下的模板中，例如php有include和require，smarty有include，假如一个a模板要引入b和c，那么就在a中直接写

```php
<?php include('b.php')?>
<?php include('c.php')?>
```

这种做法当然可以，但是在页面复杂的时候不可取，理由首先是不够灵活，现在我的a页面要套b和c，但是随着需求改变，如果我要新增一个把c换成d的页面，那么得重新写一个模板，写多了很难管理。另外页面模块加载会非常散乱，假如a引入b、c，b引入d、c引入e、f，一个维护网站的开发人员，如果不熟悉这个模块，他要改的东西在e中，得从页面开始找到a，从a找到b、c，从c找到e，才能定位到模板所在，在模块非常多的情况下，这会让维护人员抓狂。另外，联调的时候让写php的工程师拼页面本来就是一件繁琐的工作，而这种简单粗暴的模块拆分方式，无疑加重了他们的麻烦，拼接页面的时候找来找去，相信会让非常多工程师受不了。

那么有没有聪明的做法？当然有，例如，可以事先把模块规划成对象，然后利用php封装，采用搭积木的方式在统一的地方进行拼接，例如——

（以下代码参考某框架，感谢曾经有幸一起共事的几位开发者，感谢某优秀前端开发团队，我以曾经是团队中一员为荣!）

```php
$page = new Page($data);               
    $page->add('header',new xHeader($hd));
    $page->add('search',new xBase($b3search, 'search'));
    $page->add('list',new xBase($show_list, 'list'));
    $page->add('pager',new xBase($pager, 'pager'));
    $page->add('footer',new xFooter());
        $page->extJs('piao/ext/switchcity.js');
```

我们会看到，这种方式下，有了页面、层和模块的概念，而这些布局、模块和内容，可以在一段php代码中build出来，易于统一管理和维护。而且这种代码方式，对php程序员来说更亲切（这样，在忙的时候，我们就更容易骗他们为我们干活），页面像搭积木一样，这多简单~

不过这也有一些不足之处，首先你必须先约定Header、Footer和其他容器的命名和相互关系，其次，你必须封装和扩展对应的类，第三，在页面比较复杂的时候，比如层嵌套的时候，这种描述也不那么直观，你很难直接看出数据与结构模块之间的关联关系。最后，它并没有想象中的那么灵活，在不额外开发的情况下，你不能随意配置和使用各种Layout结构和模块。

那么，我们有什么解决方案呢？先看下面一段代码——

```php
$layout->{'Header hd'} = $hd;
$layout->{'Header search'} = $b3search;
$layout->{'Body list'} = $showlist;
$layout->{'Body pager'} = $pager;
$layout->{'Footer footer'} = $footer;
$layout->{'Footer extJs'} = $extJs;
```

这段代码结构简单，它把页面分成Layout容器和模块两个层级，{}之间是结构和模块的描述，模块是可以对应到views下面的module目录的文件，可以设定一个查找目录的规则，例如先找模板当前目录下的module目录，找不到，再去找views下面的module目录，这样就建立起模板管理的层级依赖关系来。=右边是赋给模板的变量，在module中可以用到。这种写法和上面一种写法的不同在于，它不用事先准备对象，所有的模块一律同样对待。它形式上只做简单直观的赋值操作，但定义了一套描述模块位置的语法。它足够灵活，不限制你构建任何模块，它只负责将这些模块找到，拼接到页面中去。它能做到足够灵活，看下面的代码：

```php
$layout->{'Header hd'} = $hd;
$layout->{'Header search'} = $b3search;
$layout->{'Body layer_gride_3_5.Left list'} = $showlist;
$layout->{'Body layer_gride_3_5.Left pager'} = $pager;
$layout->{'Body layer_gride_3_5.Right list'} = $rightside;
$layout->{'Footer footer'} = $footer;
$layout->{'Footer extJs'} = $extJs;
```

在这里，我们在模板中嵌套了另一层Layout，也就是layer_gride_3_5，它至少有Left和Right两个结构，这样我们就做到了Layout的层级嵌套。

用这套东西还能写出很多好玩的代码来，比如我可以在{}里面用变量，等等等等，还有很多可以想象的事情，这些在下一篇文章里我在详细介绍吧（=.=不过不知道下一篇啥时候更新）

最后，无码无真相，放上代码—— https://github.com/akira-cn/lafe

谢谢观赏~